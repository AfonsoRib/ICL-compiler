open OUnit2
open Icl
open Ast

let empty_env = ref (Some (Env.create_environment None))

let test_addition _ =
  assert_equal
    ~printer:string_of_eval_result
    (Int 5)
    (eval (Add (Fact 2, Fact 3)) empty_env)

let test_subtraction _ =
  assert_equal
    ~printer:string_of_eval_result
    (Int 1)
    (eval (Sub (Fact 3, Fact 2)) empty_env)

let test_multiplication _ =
  assert_equal
    ~printer:string_of_eval_result
    (Int 6)
    (eval (Mult (Fact 2, Fact 3)) empty_env)

let test_division _ =
  assert_equal
    ~printer:string_of_eval_result
    (Int 2)
    (eval (Div (Fact 6, Fact 3)) empty_env)

let test_inequality _ =
  assert_equal
    ~printer:string_of_eval_result
    (Bool true)
    (eval (Ne (Fact 5, Fact 3)) empty_env)

let test_logical_and _ =
  assert_equal
    ~printer:string_of_eval_result
    (Bool true)
    (eval (And (Statement true, Statement true)) empty_env)

let test_logical_or _ =
  assert_equal
    ~printer:string_of_eval_result
    (Bool true)
    (eval (Or (Statement false, Statement true)) empty_env)

let test_logical_not _ =
  assert_equal
    ~printer:string_of_eval_result
    (Bool false)
    (eval (Not (Statement true)) empty_env)

let test_assignment _ =
  let env = ref (Some (Env.create_environment None)) in
  let let_expr = Let ([("x", New (Fact 10), None)],
                      Seq (Assign ("x", Fact 20), Id "x"))
  in
  ignore (eval let_expr env);
  assert_equal
    ~printer:string_of_eval_result
    (Int 20)
    (eval (Deref (Id "x")) env)

let test_new_reference _ =
  match eval (New (Fact 10)) empty_env with
  | Ref r -> assert_equal ~printer:string_of_eval_result (Int 10) !r
  | _ -> assert_failure "Expected a reference type"

let test_dereference _ =
  let env = ref (Some (Env.create_environment None)) in
  ignore (eval (Let ([("x", New (Fact 10), None)], Id "x")) env);
  assert_equal
    ~printer:string_of_eval_result
    (Int 10)
    (eval (Deref (Id "x")) env)

let test_assignment _ =
  let env = ref (Some (Env.create_environment None)) in
  ignore (eval (Let [("x", New (Fact 10), None)], Assign ("x", Fact 20)) env);
  match eval (Deref (Id "x")) env with
  | Int n -> assert_equal ~printer:string_of_int 20 n
  | _ -> assert_failure "Assignment failed or incorrect dereference"

let test_while_loop _ =
  let env = ref (Some (Env.create_environment None)) in
  ignore (eval (Let [("x", Fact 0, None)], While (Lt (Id "x", Fact 5), Assign ("x", Add (Id "x", Fact 1)))) env);
  assert_equal
    ~printer:string_of_eval_result
    (Int 5)
    (eval (Id "x") env)


let suite =
  "Test Eval">:::[
    "test addition">::test_addition;
    "test subtraction">::test_subtraction;
    "test multiplication">::test_multiplication;
    "test division">::test_division;
    "test inequality">::test_inequality;
    "test logical AND">::test_logical_and;
    "test logical OR">::test_logical_or;
    "test logical NOT">::test_logical_not;
    "test let binding">::test_let_binding;
    "test new reference">::test_new_reference;
    "test dereference">::test_dereference;
    "test assignment">::test_assignment;
    "test while loop">::test_while_loop;
    (*
    "test if then else">::test_if_then_else;
    "test if then">::test_if_then;
    "test print">::test_print;
    "test println">::test_println;
    "test sequence">::test_sequence;
    *)
  ]

let () =
  run_test_tt_main suite
